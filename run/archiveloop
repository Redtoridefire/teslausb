#!/bin/bash -eu

export LOG_FILE=/mutable/archiveloop.log
export CAM_MOUNT=/mnt/cam
export MUSIC_MOUNT=/mnt/music
export ARCHIVE_MOUNT=/mnt/archive
export MUSIC_ARCHIVE_MOUNT=/mnt/musicarchive

if [ "${BASH_SOURCE[0]}" != "$0" ]
then
  echo "{BASH_SOURCE[0]} must be executed, not sourced"
  return 1 # shouldn't use exit when sourced
fi

if [ "${FLOCKED:-}" != "$0" ]
then
  if FLOCKED="$0" flock -en -E 99 "$0" "$0" "$@" || case "$?" in
  99) echo already running
      exit 99
      ;;
  *)  exit $?
      ;;
  esac
  then
    # success
    exit 0
  fi
fi


function log () {
  echo -n "$( date ): " >> "$LOG_FILE"
  echo "$1" >> "$LOG_FILE"
}

if [ ! -f /root/teslausb.conf ]
then
  log "couldn't find /root/teslausb.conf"
  exit 1
fi

source /root/teslausb.conf

if [ -z "${ARCHIVE_HOST_NAME+x}" ]
then
  log "ARCHIVE_HOST_NAME not set"
  exit 1
fi

# Utility Functions.
#
# Misc. Functions.
function isPi4 {
  grep -q "Pi 4" /sys/firmware/devicetree/base/model
}
function timestamp () {
  local prefix=${1:-}
  while IFS= read -r line
  do
    echo "$(date): $prefix$line"
  done
}
function retry () {
  local attempts=0
  while true
  do
    if eval "$@"
    then
      true
      return
    fi
    if [ "$attempts" -ge 10 ]
    then
      log "Attempts exhausted."
      false
      return
    fi
    log "Sleeping before retry..."
    /bin/sleep 1
    attempts=$((attempts + 1))
    log "Retrying..."
  done
  false
  return
}
function truncate_log () {
  local log_length=0
  log_length=$( wc -l "$LOG_FILE" | cut -d' ' -f 1 )
  if [ "$log_length" -gt 10000 ]
  then
    log "Truncating log..."
    local log_file2="${LOG_FILE}.2"
    tail -n 10000 "$LOG_FILE" > "${log_file2}"
	  mv "$log_file2" "$LOG_FILE"
  fi
}
function set_time () {
  log "Waiting for time to be set by ntpd..."
  # shellcheck disable=SC2034
  if timeout 5 ntp-wait --tries=3 --sleep=1
  then
    log "Time now set"
    return
  fi
  log "Time still not set, attempting to force it"
  if ! systemctl stop ntp
  then
    log "Failed to stop ntp daemon"
  fi
  if ! timeout 20 ntpd -q -x -g
  then
    log "Failed to set time"
  fi
  if ! systemctl start ntp
  then
    log "Failed to start ntp daemon"
  fi
}

# Blink Functions.
#
# Slow, Fast and double blink.
function slowblink () {
  echo timer > /sys/class/leds/led0/trigger
  local ON=on
  local OFF=off
  if isPi4
  then
    ON=off
    OFF=on
  fi
  echo 900 > /sys/class/leds/led0/delay_$ON
  echo 100 > /sys/class/leds/led0/delay_$OFF
}
function fastblink () {
  echo timer > /sys/class/leds/led0/trigger
  local ON=on
  local OFF=off
  if isPi4
  then
    ON=off
    OFF=on
  fi
  echo 150 > /sys/class/leds/led0/delay_$ON
  echo 50 > /sys/class/leds/led0/delay_$OFF
}
function doubleblink () {
  echo heartbeat > /sys/class/leds/led0/trigger
  if isPi4
  then
    echo 0 > /sys/class/leds/led0/invert
  else
    echo 1 > /sys/class/leds/led0/invert
  fi
}

# Generic Mount/Unmount Functions.
#
# Mount, Unmount and FSCK functions.
function mount_mountpoint () {
  local mount_point="$1"
  log "Mounting $mount_point..."

  local mounted=true
  mount "$mount_point" >> "$LOG_FILE" 2>&1 || mounted=false
  if [ "$mounted" = true ]
  then
    log "Mounted $mount_point."
    true
    return
  else
    log "Failed to mount $mount_point."
    false
    return
  fi
}
function ensure_mountpoint_is_mounted () {
  local mount_point="$1"
  local mount_exists=true

  findmnt --mountpoint "$mount_point" > /dev/null || mount_exists=false

  if [ "$mount_exists" = true ]
  then
    log "$mount_point is already mounted."
  else
    mount_mountpoint "$mount_point"
  fi
}

function ensure_mountpoint_is_mounted_with_retry () {
  retry ensure_mountpoint_is_mounted "$1"
}

function unmount_mount_point () {
  local mount_point="$1"
  log "Unmounting $mount_point..."
  if umount "$mount_point" >> "$LOG_FILE" 2>&1
  then
    log "Unmounted $mount_point."
  else
    log "Failed to unmount $mount_point, trying lazy unmount."
    if umount -l "$mount_point" >> "$LOG_FILE" 2>&1
    then
      log "lazily unmounted $mount_point"
    else
      log "lazy unmount failed"
    fi
  fi
}
function fix_errors_in_image () {
  local image="$1"
  log "Running fsck on $image..."
  losetup -f -P "$image"
  loopback=$(losetup -j "$image" | awk '{print $1}' | sed 's/://')
  /sbin/fsck "${loopback}p1" -- -a |& timestamp '| ' >> "$LOG_FILE" || echo ""
  losetup -d "$loopback"
  log "Finished fsck on $image."
}
function fix_errors_in_files () {
  fix_errors_in_image /backingfiles/cam_disk.bin
  if [ -e /backingfiles/music_disk.bin ]
  then
    fix_errors_in_image /backingfiles/music_disk.bin
  fi
}
function trim_free_space() {
  local mount_point="$1"

  # Make sure the partition is mounted.
  if found=$(findmnt -n --mountpoint "$mount_point")
  then
    loop=$(echo "$found" | awk '{print $2}')
    image=$(losetup -l -n --output=BACK-FILE "$loop")
    log "Trimming free space in $mount_point, which has $(xfs_bmap "$image" | wc -l) extents"
    if fstrim "$mount_point" >> "$LOG_FILE" 2>&1
    then
      log "Trim complete, image now has  $(xfs_bmap "$image" | wc -l) extents"
    else
      log "Trimming free space in $mount_point failed."
    fi
  fi
}

# Camera Disk Image Mount/Unmount Functions.
#
# Mount, Unmount and FSCK functions for the camera image.
function ensure_cam_file_is_mounted () {
  log "Ensuring cam file is mounted..."
  ensure_mountpoint_is_mounted_with_retry "$CAM_MOUNT"
  log "Ensured cam file is mounted."
}
function unmount_cam_file () {
  unmount_mount_point "$CAM_MOUNT"
}


# Music Disk Image Mount/Unmount Functions.
#
# Mount, Unmount and FSCK functions for the music image.
function ensure_music_file_is_mounted () {
  if [ -e "$MUSIC_MOUNT" ]
  then
    log "Ensuring music backing file is mounted..."
    ensure_mountpoint_is_mounted_with_retry "$MUSIC_MOUNT"
    log "Ensured music drive is mounted."
  fi
}
function unmount_music_file () {
  if [ -e "$MUSIC_MOUNT" ]
  then
    unmount_mount_point "$MUSIC_MOUNT"
  fi
}
function fix_errors_in_music_file () {
  if [ -e "$MUSIC_MOUNT" ]
  then
    fix_errors_in_image /backingfiles/music_disk.bin
  fi
}

# USB Drive Functions
#
# Connect and disconnect the images to the car via the g_mass_storage gadget.
function connect_usb_drives_to_host() {
  log "Connecting usb to host..."
  modprobe g_mass_storage
  log "Connected usb to host."
  # Give the file-storage process a boost in I/O priority.
  # shellcheck disable=SC2046
  ionice -c 2 -n 0 -p $( pgrep file-storage ) || true
}
function disconnect_usb_drives_from_host () {
  log "Disconnecting usb from host..."
  modprobe -r g_mass_storage
  log "Disconnected usb from host."
}
function check_if_usb_drives_is_mounted () {
    local found="false"
    for lun in /sys/devices/platform/soc/??980000.usb/gadget/lun0
    do
      if [ -d "$lun" ]
      then
        found="true"
        break
      fi
    done

    if [ "$found" = "false" ]
    then
        log "USB Gadget not mounted. Fixing files and remounting..."
        disconnect_usb_drives_from_host
        fix_errors_in_files
        connect_usb_drives_to_host
    fi
}


# Archive Detection Functions
#
# Connect and disconnect the images to the car via the g_mass_storage gadget.
function archive_is_reachable () {
  local reachable=true

  /root/bin/archive-is-reachable.sh "$ARCHIVE_HOST_NAME" || reachable=false

  if [ "$reachable" = false ]
  then
    false
    return
  fi
  true
}
function wait_for_archive_to_be_reachable () {
  log "Waiting for archive to be reachable..."
  while true
  do
    if archive_is_reachable
    then
      log "Archive is reachable."
      break
    fi
    if [ -e /tmp/archive_is_reachable ]
    then
      log "Simulating archive is reachable"
      rm /tmp/archive_is_reachable
      break
    fi
    sleep 1
  done
}
function wait_for_archive_to_be_unreachable () {
  log "Waiting for archive to be unreachable..."
  while true
    do
      if ! retry archive_is_reachable
      then
        log "Archive is unreachable."
        break
      fi
      if [ -e /tmp/archive_is_unreachable ]
      then
        log "Simulating archive being unreachable."
        rm /tmp/archive_is_unreachable
        break
      fi
      sleep 1
  done
}

# Sentry Mode Functions.
#
# Functions to turn sentry mode on and off.
# Uses the global 'is_sentry_mode_enabled'
declare is_sentry_mode_enabled

function turn_sentry_mode_on () {
  shopt -q -o pipefail
  local resetpipefail=$?
  set -o pipefail

  if [ -x /root/bin/tesla_api.py ]
  then
    is_sentry_mode_enabled=$(/root/bin/tesla_api.py is_sentry_mode_enabled | tr '[:upper:]' '[:lower:]')
    if [ "false" = "${is_sentry_mode_enabled}" ]
    then
      log "Temporarily enabling Sentry Mode to power the RPi while archive job completes..."
      if ! /root/bin/tesla_api.py enable_sentry_mode |& timestamp '| ' >>  ${LOG_FILE}
      then
        log "Could not enable Sentry Mode..."
      fi
    fi
  fi
  if [ "$resetpipefail" -eq 1 ]
  then
    set +o pipefail
  fi
}
function turn_sentry_mode_off () {
  shopt -q -o pipefail
  local resetpipefail=$?
  set -o pipefail

  if [ -x /root/bin/tesla_api.py ]
  then
	  if [ "false" = "${is_sentry_mode_enabled}" ]
	  then
	    log "Restoring Sentry Mode to its previous state (disabled)..."
      if ! /root/bin/tesla_api.py disable_sentry_mode |& timestamp '| ' >> ${LOG_FILE}
      then
        log "Could not disable Sentry Mode..."
      fi
	  fi
	fi
  if [ "$resetpipefail" -eq 1 ]
  then
    set +o pipefail
  fi
}

if [ "${SNAPSHOTS_ENABLED:-true}" = "true" ]
then
  function mv_file_to {
    local group="${1}"
    local file="${2}"

    local localdir=/backingfiles/TeslaCam/${group}

    local filedir=${file%/*}
    local filename=${file##/*/}
    local filedate=${filename:0:10}
    local filehour=${filename:11:2}
    local fileparentdir=${filedir##/*/}

    if [ "${group}" == "RecentClips" ]
    then
      local destdir="${localdir}/${filedate}/${filehour}"
    else
      local destdir="${localdir}/${fileparentdir}"
    fi

    if [ ! -d "${destdir}" ]
    then
      mkdir -p "${destdir}"
    fi

    local destfile="${destdir}/${filename}"
    if [ ! -e "${destfile}" ] || [ "${file}" -nt "${destfile}" ]
    then
      log "Moving ${group}/.../${filename}"
      # Set the copy to not interfere with the Tesla's I/O
      ionice -t -c 3 rm -f "${destdir}/_${filename}"
      ionice -t -c 3 cp --preserve=timestamps "${file}" "${destdir}/_${filename}"
      mv "${destdir}/_${filename}" "${destfile}"
    else
      log "Removing ${group}/.../${filename} - Already copied."
      rm "${file}"
    fi
  }
  function mv_from_image {
    local mntpoint="$1"

    for group in SentryClips SavedClips RecentClips
    do
      if [ -d "${mntpoint}/TeslaCam/${group}" ] ; then
        log "Moving files from ${mntpoint}/TeslaCam/${group}..."
        while IFS= read -r -d '' file
        do
          mv_file_to "${group}" "${file}"
        done < <( find "${mntpoint}/TeslaCam/${group}" -type f -print0 )
      else
        log "${mntpoint}/TeslaCam/${group} does not exist. Skipping move."
      fi
    done
  }
  function archive_teslacam_clips () {
    # Take a snapshot right before we start archiving files.
    /root/bin/make_snapshot.sh

    # Detach from the car so we own the drive.
    disconnect_usb_drives_from_host

    # fsck and mount $CAM_MOUNT
    fix_errors_in_image /backingfiles/cam_disk.bin
    ensure_cam_file_is_mounted

    # Copy the files out locally. This will remove the files and because of the
    # snapshot above should be largely just deleting files.
    mv_from_image "$CAM_MOUNT"

    # Remove any files recovered as part of the FSCK.
    find "${CAM_MOUNT}" -name "fsck*.rec" -delete

    # Remove empty directories.
    find ${CAM_MOUNT}/TeslaCam/ -mindepth 2 -depth -type d -empty -exec rmdir "{}" \;

    log "Camera Drive contents after video file removal:"
    find "${CAM_MOUNT}" -prinf "%10s - %P\n" |& timestamp '| ' >> "$LOG_FILE" || true

    # Trim the camera archive to reduce the number of blocks in the snapshot.
    trim_free_space "$CAM_MOUNT"

    # We can now give the mount back to the car.
    unmount_cam_file
    connect_usb_drives_to_host

    # Now that the car has the drive back we can do the archive.
    /root/bin/archive-clips.sh -m -s "/backingfiles/TeslaCam" -p SentryClips
    /root/bin/archive-clips.sh -m -s "/backingfiles/TeslaCam" -p SavedClips
    if [ "${ARCHIVE_RECENT_CLIPS:-false}" = "true" ]
    then
      if [ "${ENABLE_CAM_AND_MUSIC_DRIVES_DURING_RECENT_ARCHIVE:-false}" != "true" ]
      then
         disconnect_usb_drives_from_host
      fi

      /root/bin/archive-clips.sh -m -s "/backingfiles/TeslaCam" -p RecentClips

      if [ "${ENABLE_CAM_AND_MUSIC_DRIVES_DURING_RECENT_ARCHIVE:-false}" != "true" ]
      then
         connect_usb_drives_to_host
      fi
    fi

    # Remove empty directories.
    find /backingfiles/TeslaCam -mindepth 2 -depth -type d -empty -exec rmdir "{}" \;

    # Mark the free space for the /backingfiles.
    fstrim /backingfiles || true
  }
  function cleanup_snapshots {
    while IFS= read -r -d '' snapdir
    do
      log "Removing all old snapshot: ${snapdir}"
      umount "${snapdir}/mnt" || true
      rm -rf  "${snapdir}" &> /dev/null
    done < <( find "/backingfiles/snapshots/" -mindepth 1 -maxdepth 1 -type d -name "snap*" -print0 )
  }
  function snapshotloop {
    local interval=900
    local now=0
    local wakeup=0
    local inactivecount=0
    local prefilecount=0
    local postfilecount=0

    cleanup_snapshots

    # This captures the number of seconds since epoch in 'now'.
    printf -v now '%(%s)T' -1
    wakeup=$((now+interval))

    while true
    do
      printf -v now '%(%s)T' -1
      if [ $wakeup -gt $now ]
      then
        local tosleep=$((wakeup-now))
        log "SNAP: Periodic snapshot sleeping ${tosleep} seconds."
        sleep ${tosleep}
      fi

      # Compute the next wakeup.
      printf -v now '%(%s)T' -1
      wakeup=$((now+interval))

      prefilecount=$( find /backingfiles/TeslaCam -type f | wc -l )
      log "SNAP: Periodic snapshot started."
      /root/bin/make_snapshot.sh
      postfilecount=$( find /backingfiles/TeslaCam -type f | wc -l )

      if [ "${prefilecount}" = "${postfilecount}" ]
      then
        # There were no new files in the snapshot.
        inactivecount=$((inactivecount+1))
        if [ $inactivecount -gt 1 ] # About 30 minutes.
        then
          # remout the drives to the car to try and fix the situation.
          log "SNAP: CAM drive inactive $inactivecount times in a row. Reconnecting USB..."
          disconnect_usb_drives_from_host
          sleep 5
          check_if_usb_drives_is_mounted
        else
          log "SNAP: CAM drive inactive $inactivecount times in a row."
        fi
      else
        inactivecount=0
      fi

      # If we can reach the archive go ahead and move the files from
      # the local drive to the remote archive.
      if archive_is_reachable && [ -n "$ARCHIVE_MOUNT" ] && ! findmnt --mountpoint "$ARCHIVE_MOUNT" > /dev/null
      then
        log "SNAP: Attempting a periodic archive."
        if /root/bin/connect-archive.sh
        then
          # We don't keep the car awake here since we are taking advantage of being
          # connected to the archive. We only keep the car awake when we are in the main archive loop.
          /root/bin/archive-clips.sh -c -s "/backingfiles/TeslaCam/" -p SentryClips
          /root/bin/archive-clips.sh -c -s "/backingfiles/TeslaCam/" -p SavedClips
          if [ "${ARCHIVE_RECENT_CLIPS:-false}" = "true" ]
          then
            /root/bin/archive-clips.sh -c -s "/backingfiles/TeslaCam" -p RecentClips
          fi
        fi
        if ! /root/bin/disconnect-archive.sh
        then
          log "SNAP: Disconnect of the archive failed."
        fi
      fi
    done
  }
  function copy_music_files () {
    log "Starting music sync..."

    # Make sure nothing is mounted on $MUSIC_MOUNT
    unmount_music_file
    /root/bin/release_music_snapshot.sh

    # Take a snapshot of the music image to update.
    /root/bin/make_music_snapshot.sh

    # Update the music.
    /root/bin/copy-music.sh

    # Trim the empty space from the music archive.
    trim_free_space "$MUSIC_MOUNT"

    # Unmount the snapshot - Updated copy is /backingfiles/music_disk.bin.snap.
    /root/bin/release_music_snapshot.sh

    # Now swap the images.
    disconnect_usb_drives_from_host

    rm -f /backingfiles/music_disk.bin.old
    if mv /backingfiles/music_disk.bin /backingfiles/music_disk.bin.old
    then
      if mv /backingfiles/music_disk.bin.snap /backingfiles/music_disk.bin
      then
        log "Updated Music from Archive via snapshot."
       else
         mv -f /backingfiles/music_disk.bin.old /backingfiles/music_disk.bin
         log "Final move failed on  update Music from Archive via snapshot."
      fi
    else
      log "Move failed on  update Music from Archive via snapshot."
    fi

    connect_usb_drives_to_host

    rm -r /backingfiles/music_disk.bin.old
  }
else
  function archive_teslacam_clips () {
    log "Checking saved folder count..."

    ensure_cam_file_is_mounted

    DIR_COUNT=$(cd "$CAM_MOUNT"/TeslaCam && find . -maxdepth 2 -path './SavedClips/*' -type d -o -path './SentryClips/*' -type d | wc -l)
    FILE_COUNT=$(cd "$CAM_MOUNT"/TeslaCam && find . -maxdepth 3 -path './SavedClips/*' -type f -o -path './SentryClips/*' -type f | wc -l)

    log "There are $DIR_COUNT event folder(s) with $FILE_COUNT file(s) to move."

    if [ "$DIR_COUNT" -gt 0 ]
    then
        log "Starting recording archiving: $DIR_COUNT event folder(s) with $FILE_COUNT file(s)"

        /root/bin/send-push-message "TeslaUSB:" "Archiving $DIR_COUNT event folder(s) with $FILE_COUNT file(s) starting at $(date)"

        /root/bin/archive-clips.sh -m -s "$CAM_MOUNT/TeslaCam" -p SentryClips
        /root/bin/archive-clips.sh -m -s "$CAM_MOUNT/TeslaCam" -p SavedClips

        # Remove empty directories.
        find $CAM_MOUNT/TeslaCam/ -mindepth 2 -depth -type d -empty -exec rmdir "{}" \;

        # Trim the camera archive to reduce the number of blocks in the snapshot.
        trim_free_space "$CAM_MOUNT"
    fi

    # Trim the camera archive to reduce the number of blocks in the snapshot.
    trim_free_space "$CAM_MOUNT"

    # Mark the free space for the /backingfiles.
    fstrim /backingfiles || true

    unmount_cam_file
    connect_usb_drives_to_host
  }
  function copy_music_files () {
    log "Starting music sync..."

    disconnect_usb_drives_from_host

    fix_errors_in_music_file

    ensure_music_file_is_mounted

    /root/bin/copy-music.sh

    # Trim the empty space from the music archive.
    trim_free_space "$MUSIC_MOUNT"

    unmount_music_file
    connect_usb_drives_to_host
  }
  function snapshotloop {
    return 0
  }
fi


function archive_clips () {
  log "Archiving..."

  # Enable sentry mode to keep the power on, if we can.
  turn_sentry_mode_on

  if ! /root/bin/connect-archive.sh
  then
    log "Couldn't connect archive, skipping archive step"
    return
  fi

  if archive_teslacam_clips
  then
    log "Finished archiving."
  else
    log "Archiving failed."
  fi

  if timeout 5 [ -d "$MUSIC_ARCHIVE_MOUNT" -a -d "$MUSIC_MOUNT" ]
  then
    log "Copying music..."
    if copy_music_files
    then
      log "Finished copying music."
    else
      log "Copying music failed."
    fi
  else
    log "Music archive not configured or unreachable"
  fi

  /root/bin/disconnect-archive.sh

  # Disable sentry mode to let the car go to sleep.
  turn_sentry_mode_off
}

export ARCHIVE_HOST_NAME
export -f mount_mountpoint
export -f ensure_mountpoint_is_mounted
export -f retry
export -f ensure_mountpoint_is_mounted_with_retry
export -f log
export -f fix_errors_in_image
export -f timestamp

echo "==============================================" >> "$LOG_FILE"
log "Starting archiveloop..."

# Let make sure the drives are in good shape.
disconnect_usb_drives_from_host
fix_errors_in_files
connect_usb_drives_to_host

# turning off hdmi saves a little bit of power
/usr/bin/tvservice -o

# Mark the free space for the /backingfiles.
fstrim /backingfiles || true

snapshotloop &

if archive_is_reachable
then
  fastblink

  set_time

  archive_clips
  truncate_log
  doubleblink

  connect_usb_drives_to_host

  wait_for_archive_to_be_unreachable
else
  slowblink
fi

while true
do
  slowblink

  wait_for_archive_to_be_reachable

  # Start the archive loop.
  fastblink
  set_time
  sleep "${ARCHIVE_DELAY:-20}"

  archive_clips
  truncate_log
  doubleblink

  wait_for_archive_to_be_unreachable

  check_if_usb_drives_is_mounted
done
